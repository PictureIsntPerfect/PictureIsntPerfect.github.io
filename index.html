<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Video Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        video {
            transform: scaleX(-1); /* Mirror effect for webcam */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen">

    <div class="container mx-auto p-4 max-w-4xl">
        <h1 class="text-3xl font-bold text-center mb-6 text-indigo-400">Random Video Chat</h1>

        <div id="status" class="text-center mb-4 p-3 rounded-lg bg-gray-800 text-gray-300">Welcome! Click "Start" to find a chat partner.</div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div id="local-video-container" class="bg-gray-800 rounded-lg shadow-lg overflow-hidden">
                <h2 class="text-lg font-semibold p-3 bg-gray-700">You</h2>
                <video id="localVideo" autoplay playsinline muted class="w-full h-auto"></video>
            </div>
            <div id="remote-video-container" class="bg-gray-800 rounded-lg shadow-lg overflow-hidden">
                <h2 class="text-lg font-semibold p-3 bg-gray-700">Partner</h2>
                 <div id="remote-video-placeholder" class="flex items-center justify-center h-full min-h-[200px] bg-gray-800">
                    <p class="text-gray-500">Waiting for partner...</p>
                </div>
                <video id="remoteVideo" autoplay playsinline class="w-full h-auto hidden"></video>
            </div>
        </div>

        <div class="flex justify-center space-x-4">
            <button id="startButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-300 shadow-lg">Start</button>
            <button id="hangupButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-300 shadow-lg" disabled>Hang Up</button>
        </div>
         <div class="text-center mt-4 text-sm text-gray-500">
            Your ID: <span id="userId" class="font-mono"></span>
        </div>
    </div>

    <script type="module">
        // Firebase and WebRTC implementation
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, doc, addDoc, getDoc, updateDoc, deleteDoc, onSnapshot, query, where, getDocs, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // --- Firebase Configuration ---
        // User's Firebase configuration has been added here.
        const firebaseConfig = {
          apiKey: "AIzaSyBcKpDm14W4GZqQncV1LOtS3Hn5t1kK-hw",
          authDomain: "omegle-c7bdb.firebaseapp.com",
          projectId: "omegle-c7bdb",
          storageBucket: "omegle-c7bdb.appspot.com",
          messagingSenderId: "470349324814",
          appId: "1:470349324814:web:8271072b8d4cd0de01125f",
          measurementId: "G-P65WBJMXX3"
        };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-omegle-clone';

        // --- Initialize Firebase ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- UI Elements ---
        const startButton = document.getElementById('startButton');
        const hangupButton = document.getElementById('hangupButton');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const statusDiv = document.getElementById('status');
        const userIdSpan = document.getElementById('userId');
        const remoteVideoPlaceholder = document.getElementById('remote-video-placeholder');


        // --- WebRTC Configuration ---
        const servers = {
            iceServers: [
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] },
            ],
            iceCandidatePoolSize: 10,
        };

        let pc = new RTCPeerConnection(servers);
        let localStream = null;
        let remoteStream = null;
        let currentRoomId = null;
        let unsubscribeRoom = null;
        let userId = null;

        // --- Authentication ---
        async function authSetup() {
            try {
                // When using a custom Firebase config, we must sign in anonymously.
                // The custom token is tied to a different Firebase project.
                await signInAnonymously(auth);
            } catch(e) {
                console.error("Authentication failed", e);
                statusDiv.textContent = "Authentication failed. Please refresh.";
            }

            onAuthStateChanged(auth, user => {
                if (user) {
                    userId = user.uid;
                    userIdSpan.textContent = userId;
                    console.log("Signed in with UID:", userId);
                } else {
                    userId = null;
                    userIdSpan.textContent = '';
                    console.log("User is signed out.");
                }
            });
        }
        authSetup();


        // --- Core Functions ---

        /**
         * Starts the user's camera and microphone
         */
        async function startMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;

                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            } catch (error) {
                console.error("Error accessing media devices.", error);
                statusDiv.textContent = "Could not access camera/microphone. Please allow permissions.";
                return false;
            }
            return true;
        }

        /**
         * Main function to start the matching process
         */
        async function start() {
            if (!userId) {
                statusDiv.textContent = "Authenticating... Please wait.";
                setTimeout(start, 500); // Retry after a short delay
                return;
            }
            
            startButton.disabled = true;

            const mediaSuccess = await startMedia();
            if (!mediaSuccess) {
                startButton.disabled = false;
                return;
            }
            
            hangupButton.disabled = false;
            statusDiv.textContent = "Searching for a partner...";

            const waitingPoolRef = collection(db, `artifacts/${appId}/public/data/waiting_pool`);
            const q = query(waitingPoolRef, where("status", "==", "waiting"));
            const waitingDocs = await getDocs(q);
            
            const otherWaitingDocs = waitingDocs.docs.filter(doc => doc.data().userId !== userId);


            if (otherWaitingDocs.length === 0) {
                // No one else is waiting, create a new waiting entry
                const waitingDocRef = await addDoc(waitingPoolRef, {
                    userId: userId,
                    status: "waiting",
                    createdAt: new Date(),
                });
                console.log("Added to waiting pool, doc ID:", waitingDocRef.id);
                listenForPartner(waitingDocRef.id);
            } else {
                // Someone is waiting, let's connect
                const waitingDoc = otherWaitingDocs[0]; // Connect with the first one
                const partnerId = waitingDoc.data().userId;
                console.log("Found a partner:", partnerId);

                // Create a room and invite the partner. This user is the 'caller'.
                await createAndJoinRoom(waitingDoc.id, partnerId);
            }
        }


        /**
         * Listen for a partner to join our waiting document
         */
        function listenForPartner(waitingDocId) {
             const waitingDocRef = doc(db, `artifacts/${appId}/public/data/waiting_pool`, waitingDocId);

            unsubscribeRoom = onSnapshot(waitingDocRef, async (docSnap) => {
                const data = docSnap.data();
                if (data && data.status === "connected" && data.roomId) {
                    console.log("Partner connected! Joining room as 'callee':", data.roomId);
                    statusDiv.textContent = "Partner found! Connecting...";
                    currentRoomId = data.roomId;
                    if(unsubscribeRoom) unsubscribeRoom(); 
                    
                    // This user is the 'callee'
                    await joinRoom(data.roomId);
                    // The waiting doc is no longer needed
                    await deleteDoc(waitingDocRef);
                }
            });
        }

        /**
         * Create a new room, invite the partner, and start the WebRTC offer process.
         * The user executing this is the "caller".
         */
        async function createAndJoinRoom(waitingDocId, partnerId) {
            const roomRef = doc(collection(db, `artifacts/${appId}/public/data/rooms`));
            currentRoomId = roomRef.id;

            console.log("Creating room as 'caller':", currentRoomId);

            // Setup WebRTC listeners for the caller
            setupPeerConnectionListeners(roomRef, 'caller');

            const offerDescription = await pc.createOffer();
            await pc.setLocalDescription(offerDescription);

            const offer = {
                sdp: offerDescription.sdp,
                type: offerDescription.type,
            };

            await setDoc(roomRef, { offer, callerId: userId, calleeId: partnerId });

            // Update the waiting pool document to notify the other user
            const waitingDocRef = doc(db, `artifacts/${appId}/public/data/waiting_pool`, waitingDocId);
            await updateDoc(waitingDocRef, {
                status: "connected",
                roomId: currentRoomId,
                partnerId: userId
            });

             // Listen for the answer from the 'callee'
            unsubscribeRoom = onSnapshot(roomRef, (snapshot) => {
                const data = snapshot.data();
                if (!pc.currentRemoteDescription && data?.answer) {
                    console.log('Got remote description (answer):', data.answer);
                    const answerDescription = new RTCSessionDescription(data.answer);
                    pc.setRemoteDescription(answerDescription);
                }
            });
        }


        /**
         * Join an existing room created by a caller.
         * The user executing this is the "callee".
         */
        async function joinRoom(roomId) {
            const roomRef = doc(db, `artifacts/${appId}/public/data/rooms`, roomId);
            const roomSnapshot = await getDoc(roomRef);

            if (roomSnapshot.exists()) {
                 console.log('Joining room as callee:', roomId);
                 // Setup WebRTC listeners for the callee
                 setupPeerConnectionListeners(roomRef, 'callee');

                const roomData = roomSnapshot.data();
                await pc.setRemoteDescription(new RTCSessionDescription(roomData.offer));

                const answerDescription = await pc.createAnswer();
                await pc.setLocalDescription(answerDescription);

                const answer = {
                    type: answerDescription.type,
                    sdp: answerDescription.sdp,
                };

                await updateDoc(roomRef, { answer });
            } else {
                console.error("Room does not exist!");
                statusDiv.textContent = "Error: Connection room not found.";
                hangUp();
            }
        }

        /**
         * Set up all the necessary listeners on the RTCPeerConnection object,
         * differentiating between the 'caller' and 'callee' roles.
         */
        function setupPeerConnectionListeners(roomRef, role) {
             const callerCandidatesCollection = collection(roomRef, 'callerCandidates');
             const calleeCandidatesCollection = collection(roomRef, 'calleeCandidates');

            pc.ontrack = (event) => {
                console.log('Got remote track:', event.streams[0]);
                statusDiv.textContent = "Connected!";
                remoteStream = event.streams[0];
                remoteVideo.srcObject = remoteStream;
                remoteVideo.classList.remove('hidden');
                remoteVideoPlaceholder.classList.add('hidden');
            };

            if (role === 'caller') {
                // The caller sends candidates to 'callerCandidates' and listens to 'calleeCandidates'
                pc.onicecandidate = (event) => {
                    if (event.candidate) addDoc(callerCandidatesCollection, event.candidate.toJSON());
                };
                onSnapshot(calleeCandidatesCollection, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') pc.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                    });
                });
            } else { // role === 'callee'
                // The callee sends candidates to 'calleeCandidates' and listens to 'callerCandidates'
                pc.onicecandidate = (event) => {
                    if (event.candidate) addDoc(calleeCandidatesCollection, event.candidate.toJSON());
                };
                onSnapshot(callerCandidatesCollection, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') pc.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                    });
                });
            }
        }

        /**
         * Hang up the call, clean up streams and Firebase documents.
         */
        async function hangUp() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
            }

            if (pc) {
                pc.close();
            }

            // Clean up UI
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            remoteVideo.classList.add('hidden');
            remoteVideoPlaceholder.classList.remove('hidden');
            statusDiv.textContent = "Call ended. Click 'Start' to find a new partner.";
            startButton.disabled = false;
            hangupButton.disabled = true;

            // Clean up Firebase room
            if (currentRoomId) {
                const roomRef = doc(db, `artifacts/${appId}/public/data/rooms`, currentRoomId);
                const collections = ['callerCandidates', 'calleeCandidates'];
                for (const coll of collections) {
                    const candidatesSnapshot = await getDocs(collection(roomRef, coll));
                    candidatesSnapshot.forEach(async (candidateDoc) => await deleteDoc(candidateDoc.ref));
                }
                await deleteDoc(roomRef);
            }
            
            // Also delete from waiting pool if the user hangs up while waiting
            const waitingPoolRef = collection(db, `artifacts/${appId}/public/data/waiting_pool`);
            const q = query(waitingPoolRef, where("userId", "==", userId));
            const waitingDocs = await getDocs(q);
            waitingDocs.forEach(async (doc) => await deleteDoc(doc.ref));

            // Reset state for a new call
            pc = new RTCPeerConnection(servers);
            currentRoomId = null;
            if (unsubscribeRoom) {
                unsubscribeRoom();
                unsubscribeRoom = null;
            }
        }

        // --- Event Listeners ---
        startButton.onclick = start;
        hangupButton.onclick = hangUp;
        
        window.onbeforeunload = hangUp;

    </script></body>
</html>
