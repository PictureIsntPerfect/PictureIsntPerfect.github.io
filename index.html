<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Chat - Omegle Clone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        video {
            transform: scaleX(-1); /* Mirror effect for webcam */
        }
        #admin-streams video {
             transform: scaleX(-1); /* Mirror effect for webcam */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen antialiased">

    <!-- Main Application Wrapper -->
    <div id="app" class="w-full max-w-6xl mx-auto p-4">

        <!-- Header -->
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-cyan-400">Random Video Chat</h1>
            <p class="text-gray-400 mt-2">Connect with strangers from around the world.</p>
        </header>
        
        <!-- Admin Login Button -->
        <div id="admin-login-button-container" class="text-center mb-4">
            <button id="adminLoginBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Admin Login</button>
        </div>

        <!-- Admin Login Modal -->
        <div id="adminLoginModal" class="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center hidden z-50">
            <div class="bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-sm">
                <h2 class="text-2xl font-bold text-center mb-6">Admin Access</h2>
                <input id="username" type="text" placeholder="Username" class="w-full p-3 mb-4 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-400 text-white">
                <input id="password" type="password" placeholder="Password" class="w-full p-3 mb-4 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-400 text-white">
                <button id="loginSubmit" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 rounded-lg transition duration-300">Login</button>
                <button id="closeModal" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 rounded-lg transition duration-300 mt-2">Cancel</button>
                <p id="loginError" class="text-red-500 text-center mt-4 hidden">Invalid credentials.</p>
            </div>
        </div>

        <!-- Main Content: Chat or Admin Panel -->
        <main id="main-content" class="w-full">
            <!-- User Chat Interface -->
            <div id="chat-interface">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Local Video -->
                    <div class="bg-gray-800 rounded-2xl shadow-lg p-2 aspect-video flex flex-col">
                        <video id="localVideo" autoplay playsinline muted class="w-full h-full object-cover rounded-lg"></video>
                        <span class="text-center pt-2 text-gray-400">You</span>
                    </div>
                    <!-- Remote Video -->
                    <div class="bg-gray-800 rounded-2xl shadow-lg p-2 aspect-video flex flex-col">
                        <div id="remote-video-container" class="w-full h-full flex items-center justify-center bg-black rounded-lg">
                             <video id="remoteVideo" autoplay playsinline class="w-full h-full object-cover rounded-lg hidden"></video>
                             <div id="waiting-message" class="text-gray-500">Waiting for a partner...</div>
                        </div>
                        <span class="text-center pt-2 text-gray-400">Stranger</span>
                    </div>
                </div>

                <!-- Controls -->
                <div class="mt-6 text-center">
                    <button id="startBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-full transition duration-300 shadow-lg text-lg">Start Chat</button>
                    <button id="nextBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full transition duration-300 shadow-lg text-lg hidden">Next Chat</button>
                    <button id="stopBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-full transition duration-300 shadow-lg text-lg hidden">Stop</button>
                </div>
                 <p id="status" class="text-center mt-4 text-gray-400">Press 'Start Chat' to begin.</p>
            </div>

            <!-- Admin Panel -->
            <div id="admin-panel" class="hidden">
                <h2 class="text-3xl font-bold text-center mb-6 text-cyan-400">Admin Dashboard - Live Streams</h2>
                <div id="admin-streams" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    <!-- Admin streams will be dynamically added here -->
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-omegle-clone';
        
        let app, db, auth;
        let userId;

        // --- DOM Elements ---
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const startBtn = document.getElementById('startBtn');
        const nextBtn = document.getElementById('nextBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusEl = document.getElementById('status');
        const adminLoginBtn = document.getElementById('adminLoginBtn');
        const adminLoginModal = document.getElementById('adminLoginModal');
        const adminLoginButtonContainer = document.getElementById('admin-login-button-container');
        const closeModal = document.getElementById('closeModal');
        const loginSubmit = document.getElementById('loginSubmit');
        const chatInterface = document.getElementById('chat-interface');
        const adminPanel = document.getElementById('admin-panel');
        const adminStreamsContainer = document.getElementById('admin-streams');
        const waitingMessage = document.getElementById('waiting-message');


        // --- State Management ---
        let localStream;
        let peerConnection;
        let currentChatId = null;
        let isFindingPartner = false;
        let isAdmin = false;
        let unsubscribeUser, unsubscribeChat;

        const servers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
            ],
        };

        // --- Initialization ---
        async function init() {
            if (Object.keys(firebaseConfig).length === 0) {
                 statusEl.textContent = 'Firebase config not found. App cannot run.';
                 console.error("Firebase config is missing.");
                 return;
            }
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            onAuthStateChanged(auth, user => {
                if (user) {
                    userId = user.uid;
                    startLocalVideo();
                } else {
                    signInAnonymously(auth).catch(error => {
                        console.error("Anonymous sign-in failed:", error);
                        statusEl.textContent = "Authentication failed. Please refresh.";
                    });
                }
            });
        }

        // --- Core Functions ---
        async function startLocalVideo() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                startBtn.disabled = false;
                statusEl.textContent = "Ready to connect.";
            } catch (error) {
                console.error("Error accessing media devices.", error);
                statusEl.textContent = "Could not access camera/mic. Please allow permissions.";
                startBtn.disabled = true;
            }
        }

        async function startChat() {
            if (!userId || isFindingPartner) return;
            isFindingPartner = true;
            statusEl.textContent = "Searching for a partner...";
            startBtn.classList.add('hidden');
            nextBtn.classList.remove('hidden');
            stopBtn.classList.remove('hidden');

            await cleanupPreviousChat();

            try {
                // Find a waiting user
                const usersRef = collection(db, `artifacts/${appId}/public/data/users`);
                const q = query(usersRef, where("status", "==", "waiting"));
                const querySnapshot = await getDocs(q);
                
                let partnerId = null;
                querySnapshot.forEach(doc => {
                    if (doc.id !== userId && !partnerId) {
                        partnerId = doc.id;
                    }
                });

                if (partnerId) {
                    // Found a partner, create a chat room
                    currentChatId = `${userId}_${partnerId}`;
                    const chatRef = doc(db, `artifacts/${appId}/public/data/chats`, currentChatId);

                    // Caller updates their status and creates the chat
                    const batch = writeBatch(db);
                    batch.update(doc(db, `artifacts/${appId}/public/data/users`, userId), { status: 'chatting', chatId: currentChatId });
                    batch.update(doc(db, `artifacts/${appId}/public/data/users`, partnerId), { status: 'chatting', chatId: currentChatId });
                    batch.set(chatRef, { users: [userId, partnerId] });
                    await batch.commit();
                    
                    await createPeerConnection(currentChatId, true);

                } else {
                    // No partner found, become a waiting user
                    await setDoc(doc(db, `artifacts/${appId}/public/data/users`, userId), { status: 'waiting', id: userId });
                    statusEl.textContent = "Waiting for a partner to connect...";

                    // Listen for another user to create a chat with us
                    listenForChatInitiation();
                }
            } catch (error) {
                console.error("Error starting chat:", error);
                statusEl.textContent = "Error finding a partner. Please try again.";
                resetState();
            } finally {
                isFindingPartner = false;
            }
        }
        
        function listenForChatInitiation() {
            if (unsubscribeUser) unsubscribeUser();
            const userDocRef = doc(db, `artifacts/${appId}/public/data/users`, userId);
            unsubscribeUser = onSnapshot(userDocRef, async (docSnap) => {
                const data = docSnap.data();
                if (data && data.status === 'chatting' && data.chatId) {
                    if (unsubscribeUser) unsubscribeUser(); // Stop listening once a chat is found
                    currentChatId = data.chatId;
                    statusEl.textContent = "Partner found! Connecting...";
                    await createPeerConnection(currentChatId, false); // This user is the callee
                }
            });
        }


        async function createPeerConnection(chatId, isCaller) {
            peerConnection = new RTCPeerConnection(servers);

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.ontrack = event => {
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.classList.remove('hidden');
                    waitingMessage.classList.add('hidden');
                    statusEl.textContent = "Connected!";
                }
            };
            
            const chatRef = doc(db, `artifacts/${appId}/public/data/chats`, chatId);
            const offerCandidatesRef = collection(chatRef, 'offerCandidates');
            const answerCandidatesRef = collection(chatRef, 'answerCandidates');

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    const candidatesRef = isCaller ? offerCandidatesRef : answerCandidatesRef;
                    setDoc(doc(candidatesRef), { ...event.candidate.toJSON() });
                }
            };
            
            if (isCaller) {
                const offerDescription = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offerDescription);
                const offer = { sdp: offerDescription.sdp, type: offerDescription.type };
                await setDoc(chatRef, { offer }, { merge: true });

                // Listen for answer
                unsubscribeChat = onSnapshot(chatRef, async (snapshot) => {
                    const data = snapshot.data();
                    if (data && data.answer && !peerConnection.currentRemoteDescription) {
                        const answerDescription = new RTCSessionDescription(data.answer);
                        await peerConnection.setRemoteDescription(answerDescription);
                    }
                });

                // Listen for answerer's ICE candidates
                onSnapshot(answerCandidatesRef, snapshot => {
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added') {
                            peerConnection.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                        }
                    });
                });

            } else { // Callee logic
                unsubscribeChat = onSnapshot(chatRef, async (snapshot) => {
                    const data = snapshot.data();
                    if (data && data.offer && !peerConnection.currentRemoteDescription) {
                        const offerDescription = new RTCSessionDescription(data.offer);
                        await peerConnection.setRemoteDescription(offerDescription);

                        const answerDescription = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answerDescription);
                        const answer = { sdp: answerDescription.sdp, type: answerDescription.type };
                        await setDoc(chatRef, { answer }, { merge: true });
                    }
                });
                
                // Listen for offerer's ICE candidates
                onSnapshot(offerCandidatesRef, snapshot => {
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added') {
                           peerConnection.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                        }
                    });
                });
            }
        }
        
        async function cleanupPreviousChat() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if(unsubscribeChat) unsubscribeChat();
            if(unsubscribeUser) unsubscribeUser();

            remoteVideo.srcObject = null;
            remoteVideo.classList.add('hidden');
            waitingMessage.classList.remove('hidden');

            if (currentChatId) {
                const chatRef = doc(db, `artifacts/${appId}/public/data/chats`, currentChatId);
                const chatDoc = await getDoc(chatRef);
                if (chatDoc.exists()) {
                    await deleteDoc(chatRef);
                }
                currentChatId = null;
            }
            if(userId) {
                await deleteDoc(doc(db, `artifacts/${appId}/public/data/users`, userId)).catch(() => {});
            }
        }
        
        function resetState() {
             cleanupPreviousChat();
             isFindingPartner = false;
             startBtn.classList.remove('hidden');
             nextBtn.classList.add('hidden');
             stopBtn.classList.add('hidden');
             statusEl.textContent = "Ready to connect.";
        }
        
        async function stopChat() {
            await cleanupPreviousChat();
            resetState();
            statusEl.textContent = "Chat ended. Press 'Start Chat' to begin again.";
        }
        
        async function nextChat() {
            await stopChat();
            startChat();
        }

        // --- Admin Functions ---
        function handleAdminLogin() {
            const usernameInput = document.getElementById('username');
            const passwordInput = document.getElementById('password');
            const loginError = document.getElementById('loginError');

            if (usernameInput.value === 'KHEMIST' && passwordInput.value === 'TEST2121') {
                isAdmin = true;
                adminLoginModal.classList.add('hidden');
                chatInterface.classList.add('hidden');
                adminLoginButtonContainer.classList.add('hidden');
                adminPanel.classList.remove('hidden');
                startAdminView();
            } else {
                loginError.classList.remove('hidden');
            }
        }
        
        // This is a simplified "spy" functionality. In a real-world scenario,
        // this would require a media server (SFU/MCU) for scalability and privacy.
        // This implementation creates a peer connection to each active user,
        // which is not efficient for many users.
        function startAdminView() {
            const usersRef = collection(db, `artifacts/${appId}/public/data/users`);
            onSnapshot(usersRef, (snapshot) => {
                adminStreamsContainer.innerHTML = ''; // Clear previous streams
                snapshot.forEach(docSnap => {
                    const user = docSnap.data();
                    if (user.id !== userId) { // Don't show the admin's own stream
                        const videoContainer = document.createElement('div');
                        videoContainer.className = 'bg-gray-800 rounded-lg p-2 shadow-lg';
                        videoContainer.innerHTML = `
                            <video id="admin_vid_${user.id}" autoplay playsinline class="w-full h-full object-cover rounded"></video>
                            <p class="text-center text-xs pt-1 truncate" title="${user.id}">User: ${user.id}</p>
                            <p class="text-center text-xs text-cyan-400">Status: ${user.status}</p>
                        `;
                        adminStreamsContainer.appendChild(videoContainer);
                        
                        // In a real app, you would initiate a WebRTC connection here to
                        // receive the stream from each user. This requires significant
                        // additional signaling logic, where each user would also need
                        // to create a peer connection with the admin. This is omitted
                        // for complexity reasons but is the logical next step.
                        // For this example, we just display their status.
                    }
                });
            });
        }
        

        // --- Event Listeners ---
        startBtn.addEventListener('click', startChat);
        nextBtn.addEventListener('click', nextChat);
        stopBtn.addEventListener('click', stopChat);
        
        adminLoginBtn.addEventListener('click', () => adminLoginModal.classList.remove('hidden'));
        closeModal.addEventListener('click', () => adminLoginModal.classList.add('hidden'));
        loginSubmit.addEventListener('click', handleAdminLogin);

        window.addEventListener('beforeunload', () => {
             if (userId) {
                cleanupPreviousChat();
             }
        });

        init();

    </script>
</body>
</html>
