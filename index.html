<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Chat - Omegle Clone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        video {
            transform: scaleX(-1); /* Mirror effect for webcam */
        }
        #admin-streams video {
             transform: scaleX(-1); /* Mirror effect for webcam */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen antialiased">

    <!-- Main Application Wrapper -->
    <div id="app" class="w-full max-w-6xl mx-auto p-4">

        <!-- Header -->
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-cyan-400">Random Video Chat</h1>
            <p class="text-gray-400 mt-2">Connect with strangers from around the world.</p>
        </header>
        
        <!-- Admin Login Button -->
        <div id="admin-login-button-container" class="text-center mb-4">
            <button id="adminLoginBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Admin Login</button>
        </div>

        <!-- Admin Login Modal -->
        <div id="adminLoginModal" class="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center hidden z-50">
            <div class="bg-gray-800 p-8 rounded-2xl shadow-2xl w-full max-w-sm">
                <h2 class="text-2xl font-bold text-center mb-6">Admin Access</h2>
                <input id="username" type="text" placeholder="Username" class="w-full p-3 mb-4 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-400 text-white">
                <input id="password" type="password" placeholder="Password" class="w-full p-3 mb-4 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-400 text-white">
                <button id="loginSubmit" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 rounded-lg transition duration-300">Login</button>
                <button id="closeModal" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 rounded-lg transition duration-300 mt-2">Cancel</button>
                <p id="loginError" class="text-red-500 text-center mt-4 hidden">Invalid credentials.</p>
            </div>
        </div>

        <!-- Main Content: Chat or Admin Panel -->
        <main id="main-content" class="w-full">
            <!-- User Chat Interface -->
            <div id="chat-interface">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Local Video -->
                    <div class="bg-gray-800 rounded-2xl shadow-lg p-2 aspect-video flex flex-col">
                        <video id="localVideo" autoplay playsinline muted class="w-full h-full object-cover rounded-lg"></video>
                        <span class="text-center pt-2 text-gray-400">You</span>
                    </div>
                    <!-- Remote Video -->
                    <div class="bg-gray-800 rounded-2xl shadow-lg p-2 aspect-video flex flex-col">
                        <div id="remote-video-container" class="w-full h-full flex items-center justify-center bg-black rounded-lg">
                             <video id="remoteVideo" autoplay playsinline class="w-full h-full object-cover rounded-lg hidden"></video>
                             <div id="waiting-message" class="text-gray-500">Waiting for a partner...</div>
                        </div>
                        <span class="text-center pt-2 text-gray-400">Stranger</span>
                    </div>
                </div>

                <!-- Controls -->
                <div class="mt-6 text-center">
                    <button id="startBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-full transition duration-300 shadow-lg text-lg">Start Chat</button>
                    <button id="nextBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full transition duration-300 shadow-lg text-lg hidden">Next Chat</button>
                    <button id="stopBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-full transition duration-300 shadow-lg text-lg hidden">Stop</button>
                </div>
                 <p id="status" class="text-center mt-4 text-gray-400">Press 'Start Chat' to begin.</p>
            </div>

            <!-- Admin Panel -->
            <div id="admin-panel" class="hidden">
                <h2 class="text-3xl font-bold text-center mb-6 text-cyan-400">Admin Dashboard - Live Streams</h2>
                <div id="admin-streams" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    <!-- Admin streams will be dynamically added here -->
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, writeBatch, updateDoc, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
          apiKey: "AIzaSyBcKpDm14W4GZqQncV1LOtS3Hn5t1kK-hw",
          authDomain: "omegle-c7bdb.firebaseapp.com",
          projectId: "omegle-c7bdb",
          storageBucket: "omegle-c7bdb.appspot.com",
          messagingSenderId: "470349324814",
          appId: "1:470349324814:web:8271072b8d4cd0de01125f",
          measurementId: "G-P65WBJMXX3"
        };
        
        const appId = 'omegle-c7bdb';
        
        let app, db, auth;
        let userId;

        // --- DOM Elements ---
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const startBtn = document.getElementById('startBtn');
        const nextBtn = document.getElementById('nextBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusEl = document.getElementById('status');
        const adminLoginBtn = document.getElementById('adminLoginBtn');
        const adminLoginModal = document.getElementById('adminLoginModal');
        const adminLoginButtonContainer = document.getElementById('admin-login-button-container');
        const closeModal = document.getElementById('closeModal');
        const loginSubmit = document.getElementById('loginSubmit');
        const chatInterface = document.getElementById('chat-interface');
        const adminPanel = document.getElementById('admin-panel');
        const adminStreamsContainer = document.getElementById('admin-streams');
        const waitingMessage = document.getElementById('waiting-message');

        // --- State Management ---
        let localStream;
        let peerConnection; // For user-to-user chat
        let adminPeerConnections = {}; // For admin-to-user spying
        let adminConnections = {}; // For admin's management of spy connections
        let currentChatId = null;
        let isFindingPartner = false;
        let isAdmin = false;
        let unsubscribeUser, unsubscribeChat;

        const servers = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }],
        };

        // --- Initialization ---
        async function init() {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    const userRef = doc(db, `artifacts/${appId}/public/data/users`, userId);
                    await setDoc(userRef, { id: userId, status: 'online' }, { merge: true });
                    
                    await startLocalVideo();
                    listenForAdminRequests(); // Users must listen for spy requests
                } else {
                    signInAnonymously(auth).catch(error => {
                        console.error("Anonymous sign-in failed:", error);
                        statusEl.textContent = "Authentication failed. Please refresh.";
                    });
                }
            });
        }

        // --- Core Functions ---
        async function startLocalVideo() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                startBtn.disabled = false;
                statusEl.textContent = "Ready to connect.";
            } catch (error) {
                console.error("Error accessing media devices.", error);
                statusEl.textContent = "Could not access camera/mic. Please allow permissions.";
                startBtn.disabled = true;
            }
        }

        async function startChat() {
            if (!userId || isFindingPartner) return;
            isFindingPartner = true;
            statusEl.textContent = "Searching for a partner...";
            startBtn.classList.add('hidden');
            nextBtn.classList.remove('hidden');
            stopBtn.classList.remove('hidden');

            await cleanupPreviousChat();
            await updateDoc(doc(db, `artifacts/${appId}/public/data/users`, userId), { status: 'waiting' });

            try {
                const usersRef = collection(db, `artifacts/${appId}/public/data/users`);
                const q = query(usersRef, where("status", "==", "waiting"));
                const querySnapshot = await getDocs(q);
                
                let partnerId = null;
                querySnapshot.forEach(doc => {
                    if (doc.id !== userId && !partnerId) { partnerId = doc.id; }
                });

                if (partnerId) {
                    currentChatId = `${userId}_${partnerId}`;
                    const chatRef = doc(db, `artifacts/${appId}/public/data/chats`, currentChatId);
                    const batch = writeBatch(db);
                    batch.update(doc(db, `artifacts/${appId}/public/data/users`, userId), { status: 'chatting', chatId: currentChatId });
                    batch.update(doc(db, `artifacts/${appId}/public/data/users`, partnerId), { status: 'chatting', chatId: currentChatId });
                    batch.set(chatRef, { users: [userId, partnerId] });
                    await batch.commit();
                    await createPeerConnection(currentChatId, true);
                } else {
                    listenForChatInitiation();
                }
            } catch (error) {
                console.error("Error starting chat:", error);
                statusEl.textContent = "Error finding a partner. Please try again.";
                resetState();
            } finally {
                isFindingPartner = false;
            }
        }
        
        function listenForChatInitiation() {
            if (unsubscribeUser) unsubscribeUser();
            const userDocRef = doc(db, `artifacts/${appId}/public/data/users`, userId);
            unsubscribeUser = onSnapshot(userDocRef, async (docSnap) => {
                const data = docSnap.data();
                if (data && data.status === 'chatting' && data.chatId) {
                    if (unsubscribeUser) unsubscribeUser();
                    currentChatId = data.chatId;
                    statusEl.textContent = "Partner found! Connecting...";
                    await createPeerConnection(currentChatId, false);
                }
            });
        }

        async function createPeerConnection(chatId, isCaller) {
            peerConnection = new RTCPeerConnection(servers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
            peerConnection.ontrack = event => {
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.classList.remove('hidden');
                    waitingMessage.classList.add('hidden');
                    statusEl.textContent = "Connected!";
                }
            };
            
            const chatRef = doc(db, `artifacts/${appId}/public/data/chats`, chatId);
            const offerCandidatesRef = collection(chatRef, 'offerCandidates');
            const answerCandidatesRef = collection(chatRef, 'answerCandidates');

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    const candidatesRef = isCaller ? offerCandidatesRef : answerCandidatesRef;
                    addDoc(candidatesRef, event.candidate.toJSON());
                }
            };
            
            if (isCaller) {
                const offerDescription = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offerDescription);
                const offer = { sdp: offerDescription.sdp, type: offerDescription.type };
                await setDoc(chatRef, { offer }, { merge: true });
                unsubscribeChat = onSnapshot(chatRef, async (snapshot) => {
                    const data = snapshot.data();
                    if (data && data.answer && !peerConnection.currentRemoteDescription) {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    }
                });
                onSnapshot(answerCandidatesRef, s => s.docChanges().forEach(c => c.type === 'added' && peerConnection.addIceCandidate(new RTCIceCandidate(c.doc.data()))));
            } else {
                unsubscribeChat = onSnapshot(chatRef, async (snapshot) => {
                    const data = snapshot.data();
                    if (data && data.offer && !peerConnection.currentRemoteDescription) {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                        const answerDescription = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answerDescription);
                        const answer = { sdp: answerDescription.sdp, type: answerDescription.type };
                        await updateDoc(chatRef, { answer });
                    }
                });
                onSnapshot(offerCandidatesRef, s => s.docChanges().forEach(c => c.type === 'added' && peerConnection.addIceCandidate(new RTCIceCandidate(c.doc.data()))));
            }
        }
        
        async function cleanupPreviousChat() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if(unsubscribeChat) unsubscribeChat();
            if(unsubscribeUser) unsubscribeUser();
            remoteVideo.srcObject = null;
            remoteVideo.classList.add('hidden');
            waitingMessage.classList.remove('hidden');
            if (currentChatId) {
                await deleteDoc(doc(db, `artifacts/${appId}/public/data/chats`, currentChatId));
                currentChatId = null;
            }
            if (userId) {
                const userRef = doc(db, `artifacts/${appId}/public/data/users`, userId);
                await updateDoc(userRef, { status: 'online', chatId: null });
            }
        }
        
        function resetState() {
             cleanupPreviousChat();
             isFindingPartner = false;
             startBtn.classList.remove('hidden');
             nextBtn.classList.add('hidden');
             stopBtn.classList.add('hidden');
             statusEl.textContent = "Ready to connect.";
        }
        
        async function stopChat() {
            await cleanupPreviousChat();
            resetState();
            statusEl.textContent = "Chat ended. Press 'Start Chat' to begin again.";
        }
        
        async function nextChat() {
            await stopChat();
            await startChat();
        }

        // --- Admin Functions ---
        function handleAdminLogin() {
            if (document.getElementById('username').value === 'KHEMIST' && document.getElementById('password').value === 'TEST2121') {
                isAdmin = true;
                adminLoginModal.classList.add('hidden');
                chatInterface.classList.add('hidden');
                adminLoginButtonContainer.classList.add('hidden');
                adminPanel.classList.remove('hidden');
                startAdminView();
            } else {
                document.getElementById('loginError').classList.remove('hidden');
            }
        }

        function startAdminView() {
            const usersRef = collection(db, `artifacts/${appId}/public/data/users`);
            onSnapshot(usersRef, (snapshot) => {
                const onlineUsers = [];
                snapshot.forEach(doc => onlineUsers.push(doc.data()));
                
                const onlineUserIds = onlineUsers.map(u => u.id);
                Object.keys(adminConnections).forEach(id => {
                    if (!onlineUserIds.includes(id)) {
                        document.getElementById(`admin_container_${id}`)?.remove();
                        adminConnections[id].pc.close();
                        if (adminConnections[id].unsubscribe) adminConnections[id].unsubscribe();
                        delete adminConnections[id];
                    }
                });

                onlineUsers.forEach(user => {
                    if (user.id === userId) return;
                    const targetUserId = user.id;
                    if (!document.getElementById(`admin_container_${targetUserId}`)) {
                        const videoContainer = document.createElement('div');
                        videoContainer.id = `admin_container_${targetUserId}`;
                        videoContainer.className = 'bg-gray-800 rounded-lg p-2 shadow-lg';
                        videoContainer.innerHTML = `
                            <video id="admin_vid_${targetUserId}" autoplay playsinline class="w-full h-full object-cover rounded"></video>
                            <p class="text-center text-xs pt-1 truncate" title="${targetUserId}">User: ${targetUserId.substring(0, 8)}...</p>
                            <p id="admin_status_${targetUserId}" class="text-center text-xs text-cyan-400">Status: ${user.status}</p>`;
                        adminStreamsContainer.appendChild(videoContainer);
                        connectToUserForAdminView(targetUserId);
                    } else {
                        document.getElementById(`admin_status_${targetUserId}`).textContent = `Status: ${user.status}`;
                    }
                });
            });
        }
        
        async function connectToUserForAdminView(targetUserId) {
            const pc = new RTCPeerConnection(servers);
            adminConnections[targetUserId] = { pc };
            const videoEl = document.getElementById(`admin_vid_${targetUserId}`);
            pc.ontrack = event => { if (event.streams && event.streams[0]) { videoEl.srcObject = event.streams[0]; } };
            const requestRef = doc(db, `artifacts/${appId}/public/data/users/${targetUserId}/adminRequests`, userId);
            pc.onicecandidate = event => {
                if (event.candidate) {
                    addDoc(collection(requestRef, 'adminCandidates'), event.candidate.toJSON());
                }
            };
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            await setDoc(requestRef, { offer: { type: offer.type, sdp: offer.sdp } });
            
            adminConnections[targetUserId].unsubscribe = onSnapshot(requestRef, async (docSnap) => {
                const data = docSnap.data();
                if (data && data.answer && !pc.currentRemoteDescription) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                }
            });
            onSnapshot(collection(requestRef, 'userCandidates'), (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'added') pc.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                });
            });
        }

        function listenForAdminRequests() {
            if (!userId) return;
            const adminRequestsRef = collection(db, `artifacts/${appId}/public/data/users/${userId}/adminRequests`);
            onSnapshot(adminRequestsRef, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    const request = change.doc.data();
                    const adminId = change.doc.id;
                    if (change.type === 'added') {
                        if (adminId === userId) return;
                        const pc = new RTCPeerConnection(servers);
                        adminPeerConnections[adminId] = pc;
                        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                        pc.onicecandidate = event => {
                            if (event.candidate) addDoc(collection(db, `artifacts/${appId}/public/data/users/${userId}/adminRequests/${adminId}/userCandidates`), event.candidate.toJSON());
                        };
                        await pc.setRemoteDescription(new RTCSessionDescription(request.offer));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        const requestRef = doc(db, `artifacts/${appId}/public/data/users/${userId}/adminRequests`, adminId);
                        await updateDoc(requestRef, { answer: { type: answer.type, sdp: answer.sdp } });
                        onSnapshot(collection(db, `artifacts/${appId}/public/data/users/${userId}/adminRequests/${adminId}/adminCandidates`), (iceSnapshot) => {
                            iceSnapshot.docChanges().forEach(iceChange => { if (iceChange.type === 'added') pc.addIceCandidate(new RTCIceCandidate(iceChange.doc.data())); });
                        });
                    } else if (change.type === 'removed') {
                        if (adminPeerConnections[adminId]) {
                            adminPeerConnections[adminId].close();
                            delete adminPeerConnections[adminId];
                        }
                    }
                });
            });
        }

        // --- Event Listeners ---
        startBtn.addEventListener('click', startChat);
        nextBtn.addEventListener('click', nextChat);
        stopBtn.addEventListener('click', stopChat);
        adminLoginBtn.addEventListener('click', () => adminLoginModal.classList.remove('hidden'));
        closeModal.addEventListener('click', () => adminLoginModal.classList.add('hidden'));
        loginSubmit.addEventListener('click', handleAdminLogin);

        window.addEventListener('beforeunload', () => {
             if (!isAdmin) {
                cleanupPreviousChat();
             } else {
                 Object.keys(adminConnections).forEach(targetUserId => {
                     deleteDoc(doc(db, `artifacts/${appId}/public/data/users/${targetUserId}/adminRequests`, userId));
                 });
             }
        });

        init();

    </script>
</body>
</html>
