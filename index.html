<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACID.WAV Visualizer [v1.3 PRIVATE LINK]</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Aldrich&family=Quantico:wght@400;700&display=swap" rel="stylesheet">
    <style>
        @keyframes grid-pan {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }
        @keyframes text-glitch {
            0%, 100% { text-shadow: -1.5px -1.5px 0 #0ff, 1.5px 1.5px 0 #f0f; }
            25% { text-shadow: 1.5px 1.5px 0 #0ff, -1.5px -1.5px 0 #f0f; }
            50% { text-shadow: 1.5px -1.5px 0 #0ff, -1.5px 1.5px 0 #f0f; }
            75% { text-shadow: -1.5px 1.5px 0 #0ff, 1.5px -1.5px 0 #f0f; }
        }
        body {
            font-family: 'Quantico', sans-serif;
            background-color: #111;
            color: #0f0;
            background-image:
                linear-gradient(rgba(17, 17, 17, 0.95), rgba(17, 17, 17, 0.95)),
                repeating-linear-gradient(0deg, transparent, transparent 19px, #333 20px),
                repeating-linear-gradient(90deg, transparent, transparent 19px, #333 20px);
            background-size: 100% 100%, 20px 20px, 20px 20px;
            animation: grid-pan 30s linear infinite;
        }
        .main-panel {
            background: rgba(10, 20, 15, 0.3);
            border: 1px solid #0f0;
            box-shadow: inset 0 0 10px #0f0, 0 0 20px #0f0;
            backdrop-filter: blur(5px);
        }
        .title-font { font-family: 'Aldrich', sans-serif; }
        .glitch-text { animation: text-glitch 0.1s infinite; }
        .btn {
            font-family: 'Aldrich', sans-serif; text-transform: uppercase;
            background-color: #222; border: 1px solid #0f0; color: #0f0;
            padding: 10px 15px; transition: all 0.2s;
            box-shadow: inset 0 0 5px rgba(0,255,0,0.3);
        }
        .btn:hover:not(:disabled) { background-color: #0f0; color: #111; box-shadow: 0 0 15px #0f0; }
        .btn:disabled { border-color: #444; color: #555; box-shadow: none; cursor: not-allowed; }
        .btn.active { background-color: #0f0; color: #111; text-shadow: none; }
        input[type="range"] {
            -webkit-appearance: none; appearance: none; width: 100%; height: 8px;
            background: #222; border: 1px solid #0f0;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 10px; height: 20px;
            background: #0f0; box-shadow: 0 0 10px #0f0; cursor: pointer;
        }
        input[type="text"], input[type="color"], select {
            background-color: #1a1a1a; border: 1px solid #0f0; padding: 4px;
        }
        details summary { color: #0f0; font-family: 'Aldrich', sans-serif; cursor: pointer;}
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto space-y-8">
        <header class="text-center py-4">
            <h1 class="text-5xl md:text-7xl title-font glitch-text text-white">ACID.WAV</h1>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column: Video and Main Controls -->
            <div class="lg:col-span-2 main-panel p-4 space-y-4 rounded">
                <div class="relative bg-black border border-fuchsia-500 shadow-lg shadow-fuchsia-500/30">
                    <video id="video" class="w-full h-auto" autoplay playsinline muted></video>
                    <canvas id="canvas" class="w-full h-auto absolute top-0 left-0"></canvas>
                    <div id="strobe-overlay" class="absolute top-0 left-0 w-full h-full pointer-events-none" style="background: white; opacity: 0;"></div>
                </div>
                <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                     <button id="start-camera" class="btn col-span-full">[[ SYSTEM START ]]</button>
                     <button id="record-btn" class="btn" disabled>REC</button>
                     <button id="take-photo" class="btn" disabled>CAPTURE</button>
                     <button id="upload-btn" class="btn" disabled>SEND</button>
                     <label for="music-upload" class="btn text-center cursor-pointer">LOAD AUDIO</label>
                     <input type="file" id="music-upload" class="hidden" accept="audio/mp3,audio/wav">
                </div>
                <div id="status-bar" class="text-center font-mono h-6 text-lime-400">STATUS: OFFLINE</div>
            </div>

            <!-- Right Column: Settings Panel -->
            <div class="lg:col-span-1 main-panel p-4 space-y-3 rounded">
                <h2 class="text-2xl title-font text-center border-b border-lime-500 pb-2 mb-3">DATA-BEND UNIT</h2>
                <details open>
                    <summary class="text-lg">VISUAL FX</summary>
                    <div class="pl-4 pt-2 space-y-2 text-sm">
                        <div><label>Acid Melt</label><input type="range" id="acid-melt" min="0" max="30" value="0"></div>
                        <div><label>Sub Quake</label><input type="range" id="bass-shake" min="0" max="50" value="0"></div>
                        <div><label>Strobe</label><input type="range" id="strobe" min="0" max="100" value="0"></div>
                        <div><label>Chromatic Bleed</label><input type="range" id="rgb-shift" min="0" max="100" value="0"></div>
                        <div><label>Scanlines</label><input type="range" id="scanlines" min="0" max="10" value="0"></div>
                    </div>
                </details>
                <details open>
                    <summary class="text-lg">COLOR & TEXTURE</summary>
                     <div class="pl-4 pt-2 space-y-2 text-sm">
                        <div><label>Posterize</label><input type="range" id="posterize" min="2" max="32" value="32"></div>
                        <div><label>Hue Shift</label><input type="range" id="hue-rotate" min="0" max="360" value="0"></div>
                        <select id="color-filter" class="w-full">
                            <option value="none">Filter: None</option>
                            <option value="thermal">Filter: Thermal</option>
                            <option value="invert">Filter: Invert</option>
                        </select>
                     </div>
                </details>
                <details>
                    <summary class="text-lg">TEXT OVERLAY</summary>
                     <div class="pl-4 pt-2 space-y-2 text-sm">
                        <input type="text" id="top-text" placeholder="Top Text" class="w-full">
                        <input type="text" id="bottom-text" placeholder="Bottom Text" class="w-full">
                        <div class="flex items-center space-x-2">
                           <label>Size</label> <input type="range" id="font-size" min="10" max="100" value="40" class="flex-grow">
                           <input type="color" id="font-color" value="#00FF00" class="w-10 h-8">
                        </div>
                     </div>
                </details>
                <!-- SYSTEM LINK section is now removed from the UI -->
            </div>
        </div>
    </div>

    <script>
    const startBtn = document.getElementById('start-camera'), recordBtn = document.getElementById('record-btn');
    const photoBtn = document.getElementById('take-photo'), uploadBtn = document.getElementById('upload-btn');
    const video = document.getElementById('video'), canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
    const musicUpload = document.getElementById('music-upload'); // No more webhook input
    const statusBar = document.getElementById('status-bar');
    const strobeOverlay = document.getElementById('strobe-overlay');
    const fx = {
        acidMelt: document.getElementById('acid-melt'), bassShake: document.getElementById('bass-shake'),
        strobe: document.getElementById('strobe'), rgbShift: document.getElementById('rgb-shift'),
        scanlines: document.getElementById('scanlines'), posterize: document.getElementById('posterize'),
        hueRotate: document.getElementById('hue-rotate'), colorFilter: document.getElementById('color-filter'),
    };
    const txt = {
        top: document.getElementById('top-text'), bottom: document.getElementById('bottom-text'),
        size: document.getElementById('font-size'), color: document.getElementById('font-color'),
    };
    let localStream, mediaRecorder, audioContext, audioSource, analyser, frequencyData;
    let isRecording = false, isLive = true, animationFrameId;
    let recordedChunks = [], capturedBlob = null;
    let musicElement = new Audio();
    
    startBtn.addEventListener('click', async () => {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
            video.srcObject = localStream;
            video.onloadedmetadata = () => {
                video.play();
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                recordBtn.disabled = false; photoBtn.disabled = false;
                startBtn.disabled = true; startBtn.textContent = "[[ ONLINE ]]";
                statusBar.textContent = "STATUS: AWAITING INPUT";
                renderLoop();
            };
        } catch (err) { statusBar.textContent = "ERROR: NO CAMERA DETECTED"; }
    });

    musicUpload.addEventListener('change', e => {
        const file = e.target.files[0]; if (!file) return;
        musicElement.src = URL.createObjectURL(file);
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser(); analyser.fftSize = 256;
            frequencyData = new Uint8Array(analyser.frequencyBinCount);
            audioSource = audioContext.createMediaElementSource(musicElement);
            audioSource.connect(analyser); audioSource.connect(audioContext.destination);
        }
        musicElement.play();
        statusBar.textContent = `PLAYING: ${file.name.slice(0, 20)}...`;
    });

    const renderLoop = () => {
        if (!isLive) {
            animationFrameId = requestAnimationFrame(renderLoop);
            return;
        }

        const time = Date.now() / 150;
        let bassLevel = 0;
        if (analyser) {
            analyser.getByteFrequencyData(frequencyData);
            bassLevel = (frequencyData[2] + frequencyData[3]) / 2 / 255;
        }

        // --- RENDER PIPELINE ---
        
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.filter = `hue-rotate(${fx.hueRotate.value}deg)`;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        ctx.restore();

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;
        const sourcePixels = new Uint8ClampedArray(pixels);

        const meltAmount = parseInt(fx.acidMelt.value);
        const shiftAmount = parseInt(fx.rgbShift.value) * 4;
        const posterizeLevels = parseInt(fx.posterize.value);
        const posterizeStep = 255 / (posterizeLevels - 1);
        const currentFilter = fx.colorFilter.value;

        for (let i = 0; i < pixels.length; i += 4) {
            let r, g, b;
            let sourceIndex = i;

            if (meltAmount > 0) {
                const y = Math.floor((i / 4) / canvas.width);
                const xOffset = Math.sin(y / 20 + time) * meltAmount;
                const meltSourceIndex = i + Math.floor(xOffset) * 4;
                if (meltSourceIndex >= 0 && meltSourceIndex < sourcePixels.length) {
                    sourceIndex = meltSourceIndex;
                }
            }
            
            const redIndex = sourceIndex - shiftAmount;
            const blueIndex = sourceIndex + shiftAmount;
            r = (redIndex >= 0) ? sourcePixels[redIndex] : sourcePixels[sourceIndex];
            g = sourcePixels[sourceIndex + 1];
            b = (blueIndex < sourcePixels.length) ? sourcePixels[blueIndex + 2] : sourcePixels[sourceIndex + 2];

            r = Math.round(r / posterizeStep) * posterizeStep;
            g = Math.round(g / posterizeStep) * posterizeStep;
            b = Math.round(b / posterizeStep) * posterizeStep;

            if (currentFilter === 'invert') {
                r = 255 - r; g = 255 - g; b = 255 - b;
            } else if (currentFilter === 'thermal') {
                const brightness = (r + g + b) / 3;
                r = brightness;
                g = Math.abs(brightness - 128);
                b = 255 - brightness;
            }
            
            pixels[i] = r;
            pixels[i + 1] = g;
            pixels[i + 2] = b;
        }

        ctx.putImageData(imageData, 0, 0);

        const shakeAmount = fx.bassShake.value * bassLevel;
        if(shakeAmount > 0) {
            const shakeData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            ctx.clearRect(0,0,canvas.width, canvas.height);
            ctx.putImageData(shakeData, (Math.random() - 0.5) * shakeAmount, (Math.random() - 0.5) * shakeAmount);
        }
        
        const scanlineAmount = fx.scanlines.value;
        if (scanlineAmount > 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            for (let i = 0; i < canvas.height; i += (12 - scanlineAmount)) ctx.fillRect(0, i, canvas.width, 1);
        }
        strobeOverlay.style.opacity = Math.random() < 0.5 ? (fx.strobe.value / 100) * bassLevel : 0;
        
        const fontSize = txt.size.value;
        ctx.font = `bold ${fontSize}px Quantico`;
        ctx.fillStyle = txt.color.value;
        ctx.strokeStyle = 'black'; ctx.lineWidth = fontSize / 8;
        ctx.textAlign = 'center';
        const topText = txt.top.value.toUpperCase();
        if(topText) { ctx.strokeText(topText, canvas.width / 2, parseInt(fontSize, 10) + 10); ctx.fillText(topText, canvas.width / 2, parseInt(fontSize, 10) + 10); }
        const bottomText = txt.bottom.value.toUpperCase();
        if(bottomText) { ctx.strokeText(bottomText, canvas.width / 2, canvas.height - 20); ctx.fillText(bottomText, canvas.width / 2, canvas.height - 20); }

        animationFrameId = requestAnimationFrame(renderLoop);
    };

    // --- Controls & Upload ---
    photoBtn.addEventListener('click', () => {
        isLive = !isLive; photoBtn.classList.toggle('active');
        if (isLive) { photoBtn.textContent = "CAPTURE"; }
        else {
            photoBtn.textContent = "LIVE";
            cancelAnimationFrame(animationFrameId);
            canvas.toBlob(blob => { capturedBlob = blob; uploadBtn.disabled = false; }, 'image/png');
        }
    });
    recordBtn.addEventListener('click', () => {
        if(isRecording) {
            mediaRecorder.stop();
            recordBtn.textContent = "REC"; recordBtn.classList.remove('active');
            isRecording = false;
        } else {
            if(!isLive) photoBtn.click();
            const canvasStream = canvas.captureStream(30);
            let combinedStream = (audioContext && audioSource) ? new MediaStream([...canvasStream.getTracks(), ...audioContext.createMediaStreamDestination().stream.getTracks()]) : canvasStream;
            mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm' });
            recordedChunks = [];
            mediaRecorder.ondataavailable = e => { if(e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                 capturedBlob = new Blob(recordedChunks, { type: 'video/webm' });
                 uploadBtn.disabled = false; statusBar.textContent = "RECORDING SAVED.";
            };
            mediaRecorder.start();
            recordBtn.textContent = "STOP"; recordBtn.classList.add('active');
            isRecording = true; statusBar.textContent = "RECORDING...";
        }
    });
    uploadBtn.addEventListener('click', async () => {
        // The webhook URL is now hardcoded and not read from an input field.
        const webhookUrl = "https://discord.com/api/webhooks/1384749018722336808/cAfifhrk6BcAD3bngzmc5-eM2cdDwKjUeJ5jZjWTV8U3qYuhPnVs-T1obUDQgpxM7fSH";
        
        if (!capturedBlob) { statusBar.textContent = "NO DATA CAPTURED"; return; }
        if (capturedBlob.size > 25 * 1024 * 1024) { statusBar.textContent = "FILE TOO LARGE (>25MB)"; return; }
        statusBar.textContent = "SENDING..."; uploadBtn.disabled = true;
        try {
            const formData = new FormData();
            const fileName = capturedBlob.type === 'video/webm' ? 'acid.webm' : 'acid.png';
            formData.append('file', capturedBlob, fileName);
            const response = await fetch(webhookUrl, { method: 'POST', body: formData });
            statusBar.textContent = response.ok ? "SEND COMPLETE" : `SEND FAILED`;
        } catch (error) { statusBar.textContent = "CONNECTION ERROR";
        } finally { uploadBtn.disabled = false; }
    });
    </script>
</body>
</html>
